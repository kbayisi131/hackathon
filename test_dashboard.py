# -*- coding: utf-8 -*-
"""Test_Dashboard.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15NrbQp-qu0bVN2SWn-EZYHnbIb5vruZ6
"""

from google.colab import drive
drive.mount('/content/drive')

zip_path = "/content/drive/Shareddrives/AggieHacks2025/Smart_City_Dataset.zip"

from zipfile import ZipFile

with ZipFile(zip_path, 'r') as zip_ref:
    zip_ref.extractall("smart_city_data")

import pandas as pd
# Add in each model's data export
tweet_validity = pd.read_csv('/content/drive/Shareddrives/AggieHacks2025/tweets_df.csv')
zone_risk = pd.read_csv('/content/drive/Shareddrives/AggieHacks2025/final_zone_risk_scores.csv')
cascade_risk = pd.read_csv('/content/drive/Shareddrives/AggieHacks2025/cascade_via_gnn.csv')
disaster_df = pd.read_csv('/content/smart_city_data/Essential_Data/disaster_events.csv')

import streamlit as st
import pandas as pd
import geopandas as gpd
from shapely.geometry import Point
import matplotlib.pyplot as plt

st.set_page_config(page_title="Smart City Dashboard", layout="wide")

# -------------------------------
# Load & Process Zone Data
# -------------------------------
@st.cache_data
def load_zones():
    # Load zones GeoJSON
    zones = gpd.read_file("/content/smart_city_data/Essential_Data/city_map.geojson")
    st.write("Original Zones CRS:", zones.crs)

    # Reproject to a projected CRS for proper buffering (EPSG:3857 is in meters)
    zones_proj = zones.to_crs("EPSG:3857")
    buffer_distance_meters = 1000  # Buffer by 1000 meters; adjust as needed.
    zones_proj['geometry'] = zones_proj.buffer(buffer_distance_meters)

    # Convert back to EPSG:4326 for mapping
    zones_buffered = zones_proj.to_crs("EPSG:4326")

    # Extract centroids to create explicit lat/lon columns for mapping.
    zones_buffered['lat'] = zones_buffered.geometry.centroid.y
    zones_buffered['lon'] = zones_buffered.geometry.centroid.x

    return zones_buffered

zones_buffered = load_zones()

st.subheader("Buffered Zone Areas")
# Display zone centroids on a map (st.map requires explicit lat, lon columns)
st.map(zones_buffered[['lat', 'lon']])

# -------------------------------
# Load & Process Tweet Data
# -------------------------------
@st.cache_data
def load_tweets():
    tweets_df = pd.read_csv("/content/drive/Shareddrives/AggieHacks2025/tweets_df.csv")
    tweets_df['timestamp'] = pd.to_datetime(tweets_df['timestamp'])
    # Create geometry for tweets from longitude and latitude:
    tweets_df['geometry'] = tweets_df.apply(lambda row: Point(row['longitude'], row['latitude']), axis=1)
    # Convert to GeoDataFrame with EPSG:4326.
    tweets_gdf = gpd.GeoDataFrame(tweets_df, geometry='geometry', crs='EPSG:4326')
    return tweets_df, tweets_gdf

tweets_df, tweets_gdf = load_tweets()

# For mapping, extract latitude and longitude from tweets. Rename columns as required by st.map.
tweets_map = tweets_df[['latitude', 'longitude']].rename(columns={'latitude': 'lat', 'longitude': 'lon'})

st.subheader("Tweet Data")
st.map(tweets_map)

# -------------------------------
# Optionally, You Can Combine the Two DataFrames for a Single Map (Advanced)
# -------------------------------
# For example, if you want to overlay zones and tweets on one interactive map,
# you might create one combined dataframe with a 'source' column:
zones_points = zones_buffered[['lat', 'lon']].copy()
zones_points['source'] = 'Zone Centroid'
tweets_points = tweets_map.copy()
tweets_points['source'] = 'Tweet'
combined_df = pd.concat([zones_points, tweets_points], axis=0)

# Note: st.map does not support different marker colors, so for a more advanced overlay,
# you can use PyDeck. The code below is an optional example.
import pydeck as pdk

st.subheader("Combined Map (via PyDeck)")
# Define a layer for tweets
tweet_layer = pdk.Layer(
    "ScatterplotLayer",
    data=tweets_points,
    get_position='[lon, lat]',
    get_fill_color='[255, 0, 0, 140]',  # Red for tweets
    get_radius=50,
)

# Define a layer for zones centroids (or convert the whole buffered polygons to a layer)
zone_layer = pdk.Layer(
    "ScatterplotLayer",
    data=zones_points,
    get_position='[lon, lat]',
    get_fill_color='[0, 0, 255, 140]',  # Blue for zones
    get_radius=100,
)

# Set the initial view state
view_state = pdk.ViewState(
    longitude=combined_df['lon'].mean(),
    latitude=combined_df['lat'].mean(),
    zoom=11,
    pitch=0,
)

r = pdk.Deck(layers=[tweet_layer, zone_layer], initial_view_state=view_state, tooltip={"text": "{source}"})
st.pydeck_chart(r)